<html><head><title>Daniel Mroz | LamE</title><link href="../css/main.css" rel="stylesheet" type="text/css"><link href="../css/highlight.css" rel="stylesheet" type="text/css"><link href="https://fonts.googleapis.com/css?family=Kanit|Lora|Seymour+One|Modak" rel="stylesheet"><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" type="text/javascript" async="async"></script></head><body><div class="container"><div class="mainbar"><div class="maincontainer container"><div class="main box"><div class="center"><h1>LamE</h1></div><div class="inside"><hr><h1>The LAMbda Evaluater</h1>
<h2><a href="https://github.com/zyxw121/LamE">On GitHub</a></h2>
<h2>Defining the syntax</h2>
<p>The first thing to do is nail down the syntax of the language. It's important that the concrete syntax is: * Easy for the interpreter to parse * Easy for humans to read and write</p>
<p>Requiring lots of parantheses and keywords gives us the first, at a slight hit to the second. The syntax is more fully described <a href="https://github.com/zyxw121/LamE/blob/master/SYNTAX.md">here</a>.</p>
<p>This naturally gives rise to the following data types of expressions and definitions.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Expr</span>   <span class="ot">=</span> <span class="dt">VarExp</span> <span class="dt">Name</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>            <span class="op">|</span> <span class="dt">CharExp</span> <span class="dt">Char</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>            <span class="op">|</span> <span class="dt">ListExp</span> [<span class="dt">Expr</span>]</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>            <span class="op">|</span> <span class="dt">StringExp</span> <span class="dt">String</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>            <span class="op">|</span> <span class="dt">BoolExp</span> <span class="dt">Bool</span> </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>            <span class="op">|</span> <span class="dt">NumExp</span> <span class="dt">Int</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>            <span class="op">|</span> <span class="dt">Match</span> <span class="dt">Name</span> (<span class="dt">Name</span>, <span class="dt">Expr</span>) (<span class="dt">Name</span>, <span class="dt">Name</span>, <span class="dt">Expr</span>) (<span class="dt">Name</span>, <span class="dt">Name</span>, <span class="dt">Expr</span>)</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>            <span class="op">|</span> <span class="dt">If</span> <span class="dt">Expr</span> <span class="dt">Expr</span> <span class="dt">Expr</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>            <span class="op">|</span> <span class="dt">Func</span> [<span class="dt">Name</span>] <span class="dt">Expr</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>            <span class="op">|</span> <span class="dt">Apply</span> <span class="dt">Expr</span> [<span class="dt">Expr</span>]</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>            <span class="op">|</span> <span class="dt">Let</span> <span class="dt">Defn</span> <span class="dt">Expr</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>            <span class="kw">deriving</span> (<span class="dt">Eq</span>) </span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Defn</span>   <span class="ot">=</span> <span class="dt">Val</span> <span class="dt">Name</span> <span class="dt">Expr</span> </span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>            <span class="op">|</span> <span class="dt">Rec</span> <span class="dt">Name</span> <span class="dt">Expr</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>            <span class="kw">deriving</span> (<span class="dt">Eq</span>) </span></code></pre></div>
<p>Where <code>Match t (x,e1) (s,t,e2) (y,p,e3)</code> comes from <code>match</code> expressions:</p>
<pre><code>match t as
  (Var x) (e1)
  (App s t) (e2)
  (Abs y p) (e3)</code></pre>
<p>and <code>If c l r</code> comes from <code>if</code> expressions:</p>
<pre><code>if c then l else r</code></pre>
<p>and the meaning of the rest is clear. We may as well define the primitive functions too.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Prim</span> <span class="ot">=</span> <span class="dt">Plus</span> <span class="op">|</span> <span class="dt">Minus</span> <span class="op">|</span> <span class="dt">Times</span> <span class="op">|</span> <span class="dt">Div</span> <span class="op">|</span> <span class="dt">Mod</span> <span class="op">...</span></span></code></pre></div>
<h2>Parsing</h2>
<p>We use <a href="https://hackage.haskell.org/package/parsec">Parsec</a> to parse strings into expressions. This comes with a <a href="https://hackage.haskell.org/package/parsec-3.1.13.0/docs/Text-Parsec-Token.html#t:GenLanguageDef">handy method</a> to tokenize a string. Unfortunately, this doesn't work straight out of the box.</p>
<p>The builtin lexer consumes spaces after a token, but spaces are an important feature of our syntax when it comes to function application. So we must recreate the lexer so that it doesn't consume trailing whitespace.</p>
<p>This is not too hard, and from here it is quite straightforward to build parsers for constants, functions, etc.</p>
<p>We run into another snag when we try to parse applications, however. Consider the production rules for a fragment of our grammar:</p>
<pre><code>&lt;expr&gt;  ::= &lt;variable&gt; | &lt;expr&gt; &lt;expr&gt; | (&lt;expr&gt;)</code></pre>
<p>It's left-recursive! So the naive parser will sometimes loop. Thankfully, we can fix this by redefining the grammar.</p>
<pre><code>&lt;expr&gt;  ::= &lt;expr&#39;&gt; | &lt;expr&gt;&#39; &lt;expr&gt;   
&lt;expr&#39;&gt; ::= &lt;variable&gt; | (&lt;expr&gt;)</code></pre>
<p>The obvious parser now works. We extend this to the full grammar.</p>
<h2>Partial evaluation</h2>
<p>Now that we can turn strings into expressions we need to decide what to do with them. Constants (variables, strings, integers, etc) can be turned into into lambda-terms straightforwardly (more on this in the section on Church encodings). But what about an expression like <code>+ 1 2</code>?</p>
<p>We could translate each subexpression (<code>+</code>, <code>1</code>, and <code>2</code>) into a lambda term, and return the application. Or, <em>given that we know what <code>+</code> means</em>, we can notice that this is equal to the expression <code>3</code>.</p>
<p>So this will be our strategy: translate an expression into an intermediate form by reducing it "as much as we can". Then we translate that into a lambda-term.</p>
<p>We need to do a few things all at once now, with the end goal of defining a function <code>eval :: Expr -&gt; Env -&gt; Value</code> for some suitable types <code>Env</code> and <code>Value</code>.</p>
<p>Consider the expression <code>let val x = 1 in x</code>. This should certainly evaluate to <code>1</code>. To allow for this we'll need some type of environment, that is a mapping from names to values.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Environment</span> a <span class="ot">=</span> [(<span class="dt">Name</span>, a)]  </span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Env</span> <span class="ot">=</span> <span class="dt">Environment</span> <span class="dt">Value</span></span></code></pre></div>
<p>A list of pairs will do. This will have the added benefit of acting like a stack, so that newer definitions override older ones.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="ot">find ::</span> <span class="dt">Environment</span> a <span class="ot">-&gt;</span> <span class="dt">Name</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>find env x <span class="ot">=</span> <span class="kw">case</span> (<span class="fu">filter</span> (\(a,b) <span class="ot">-&gt;</span> a<span class="op">==</span>x) env) <span class="kw">of</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>  [] <span class="ot">-&gt;</span> <span class="dt">Nothing</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>  ((a,b)<span class="op">:</span>xs) <span class="ot">-&gt;</span> <span class="dt">Just</span> b </span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span class="ot">define ::</span> <span class="dt">Name</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Environment</span> a <span class="ot">-&gt;</span> <span class="dt">Environment</span> a</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>define x v <span class="ot">=</span> define&#39; (x,v)</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a><span class="ot">define&#39; ::</span> (<span class="dt">Name</span>, a) <span class="ot">-&gt;</span> <span class="dt">Environment</span> a <span class="ot">-&gt;</span> <span class="dt">Environment</span> a</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>define&#39; <span class="ot">=</span> (<span class="op">:</span>)</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a><span class="ot">new_env ::</span> <span class="dt">Environment</span> a</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>new_env <span class="ot">=</span> []</span></code></pre></div>
<p>We add some helper functions for manipulating and creating environments.</p>
<p>Let's think about the definition of <code>Value</code> now. Constants should pass through eval, so we'll need a value constructor for each of those. Variables should be looked up in the environment. If there's a match we can return that. But what if a variable isn't defined in the environment?</p>
<p>We have a choice. Either throw an error, or just return the variable itself. For simplicity we'll do the latter. This gives us a good start on defining <code>Value</code> and <code>eval</code>.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Value</span>  <span class="ot">=</span> <span class="dt">VarVal</span> <span class="dt">Name</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>            <span class="op">|</span> <span class="dt">CharVal</span> <span class="dt">Char</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>            <span class="op">|</span> <span class="dt">ListVal</span> [<span class="dt">Action</span>]</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>            <span class="op">|</span> <span class="dt">StringVal</span> <span class="dt">String</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>            <span class="op">|</span> <span class="dt">BoolVal</span> <span class="dt">Bool</span> </span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>            <span class="op">|</span> <span class="dt">NumVal</span> <span class="dt">Int</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>            <span class="op">|</span> <span class="dt">TermVal</span> <span class="dt">Term</span> </span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a><span class="ot">eval ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Env</span> <span class="ot">-&gt;</span> <span class="dt">Value</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>eval (<span class="dt">VarExp</span> n) env <span class="ot">=</span> <span class="kw">case</span> find env n <span class="kw">of</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Just</span> v <span class="ot">-&gt;</span> v</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">VarVal</span> n</span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>eval (<span class="dt">BoolExp</span> b) env <span class="ot">=</span> <span class="dt">BoolVal</span> b</span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>eval (<span class="dt">NumExp</span> n) env <span class="ot">=</span> <span class="dt">NumVal</span> n</span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>eval (<span class="dt">CharExp</span> c) env <span class="ot">=</span> <span class="dt">CharVal</span> c</span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>eval (<span class="dt">StringExp</span> s) env <span class="ot">=</span> <span class="dt">StringVal</span> s</span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>eval (<span class="dt">ListExp</span> xs) env <span class="ot">=</span> <span class="dt">ListVal</span> (<span class="fu">map</span> (<span class="fu">flip</span> eval <span class="op">$</span> env) xs)</span></code></pre></div>
<p>We can handle <code>If</code> expressions by hoping that the condition evaluates to a boolean and then choosing the appropriate branch (we leave the case where the condition <em>is not</em> a boolean to later):</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>eval (<span class="dt">If</span> c e1 e2) env <span class="ot">=</span> <span class="kw">case</span> (eval c env) <span class="kw">of</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">BoolVal</span> b <span class="ot">-&gt;</span> <span class="kw">if</span> b <span class="kw">then</span> (eval e1 env) <span class="kw">else</span> (eval e2 env)</span></code></pre></div>
<p><code>Match</code> expressions are a little more complicated but it's a similar idea. Again, we hope that the thing to match on evaluates to a term. Then match in Haskell to pick a branch. The semantices of <code>match</code> are that if <code>t</code> is the term <code>Var y</code> then the expression:</p>
<pre><code>match t as
  (Var x) (e1)
  (App s t) (e2)
  (Abs y p) (e3)</code></pre>
<p>evaluates to <code>e1</code> but with the variable <code>x</code> set to the value of <code>y</code>, and something similar for the other cases.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>act m<span class="op">@</span>(<span class="dt">Match</span> x (y,e1) (s,t,e2) (z,u,e3)) env <span class="ot">=</span> <span class="kw">case</span> act x env <span class="kw">of</span> </span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>  (<span class="dt">TermAct</span> (<span class="dt">Var</span> (<span class="dt">Name</span> y&#39;))) <span class="ot">-&gt;</span> act e1 (define env y (<span class="dt">StringAct</span> y&#39;) )</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>  (<span class="dt">TermAct</span> (<span class="dt">App</span> s&#39; t&#39;)) <span class="ot">-&gt;</span> act e2 (define (define env s (<span class="dt">TermAct</span> s&#39;)) t (<span class="dt">TermAct</span> t&#39;) )</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>  (<span class="dt">TermAct</span> (<span class="dt">Abs</span> (<span class="dt">Name</span> z&#39;) u&#39;)) <span class="ot">-&gt;</span> act e3 (define (define env u (<span class="dt">TermAct</span> u&#39;)) z (<span class="dt">StringAct</span> z&#39;))</span></code></pre></div>
<p>What about functions? We neatly side-step the issue by wrapping everything up into a closure.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Value</span> <span class="ot">=</span> <span class="op">...</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>           <span class="op">|</span> <span class="dt">Closure</span> [<span class="dt">Name</span>] <span class="dt">Expr</span> <span class="dt">Env</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>eval (<span class="dt">Func</span> xs e) env <span class="ot">=</span> <span class="dt">Closure</span> xs e env</span></code></pre></div>
<p>We also put off applications and let expressions till later:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>eval (<span class="dt">Apply</span> e es) env <span class="ot">=</span> apply (eval e env) (<span class="fu">map</span> (<span class="fu">flip</span> eval <span class="op">$</span> env) es)</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>eval (<span class="dt">Let</span> d e) env <span class="ot">=</span> eval e (elab d env)</span></code></pre></div>
<p>where the functions <code>apply :: Value -&gt; [Value] -&gt; Value</code> and <code>elab :: Defn -&gt; Env -&gt; Env</code> are going to do exactly what you'd think.</p>
<p>We will handle the primitive operations by adding a new constructor to <code>Value</code> ~~~ {.haskell} data Value = ... | Primitive Prim ~~~</p>
<p>Recall that the epxression <code>+ 1 2</code> parses to <code>Apply (VarExp "+") [NumExp 1, NumExp 2]</code>. That is, rather than parsing "+" directly in the primitive <code>Plus</code> we just parse it as a variable. This is similar to how Haskell does it, and it means we can redefine primitives (<code>let val + = - in + 1 1</code> will evaluate to <code>0</code>).</p>
<p>We do this by defining a default environment that contains the primitives.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>prims <span class="ot">=</span> <span class="fu">map</span> (\(n,p) <span class="ot">-&gt;</span> (<span class="dt">Name</span> n, <span class="dt">Primitive</span> p)) </span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>  [ (<span class="st">&quot;+&quot;</span>, <span class="dt">Plus</span>)</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>  , (<span class="st">&quot;-&quot;</span>, <span class="dt">Minus</span>)</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">...</span> </span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>  ]</span></code></pre></div>
<p>Let's get back to <code>apply</code> and <code>elab</code>. To apply a <code>Closure xs e env</code> to the evaluated arguments <code>vs</code> we should evalute <code>e</code> in the environment where the paramaters <code>xs</code> are bound to the arguments <code>vs</code>. We'll have a helper function to apply primitives. Applying anything else will result in a syntactic <code>Application</code> value.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Value</span> <span class="ot">=</span> <span class="op">...</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>           <span class="op">|</span> <span class="dt">Application</span> <span class="dt">Value</span> [<span class="dt">Values</span>]</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a><span class="ot">apply ::</span> <span class="dt">Value</span> <span class="ot">-&gt;</span> [<span class="dt">Values</span>] <span class="ot">-&gt;</span> <span class="dt">Value</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>apply (<span class="dt">Closure</span> xs e env) vs <span class="ot">=</span> eval v (defargs xs vs env)</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span> defargs <span class="ot">=</span> <span class="fu">foldr</span> (define&#39;) (<span class="fu">id</span>) <span class="op">.</span> <span class="fu">zip</span> </span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>apply (<span class="dt">Primitive</span> p) vs <span class="ot">=</span> applyPrim p vs</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>apply v vs <span class="ot">=</span> <span class="dt">Application</span> v vs </span></code></pre></div>
<p>We use <code>applyPrim</code> to try and simplify things if we can, and just do a formal application if we can't.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="ot">applyPrim ::</span> <span class="dt">Prim</span> <span class="ot">-&gt;</span> [<span class="dt">Value</span>] <span class="ot">-&gt;</span> <span class="dt">Value</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>applyPrim (<span class="dt">Plus</span>) [<span class="dt">NumVal</span> n, <span class="dt">NumVal</span> m] <span class="ot">=</span> <span class="dt">NumVal</span> (n <span class="op">+</span> m)</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>applyPrim (<span class="dt">Plus</span>) [<span class="dt">NumVal</span> n, <span class="dt">NumVal</span> m] <span class="ot">=</span> <span class="dt">NumVal</span> (n <span class="op">-</span> m)</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a><span class="op">...</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>applyPrim p vs <span class="ot">=</span> <span class="dt">Application</span> (<span class="dt">Primitve</span> p) vs</span></code></pre></div>
<p>Now we define <code>elab</code>, a function which adds a definition to an environment. We have two types of definitions, recursive and value (non-recursive). Value definitions are straightforward. Because the value on the right doesn't reference the name on the left, we can just evaluate it. We won't fully deal with recursive definitions yet, we'll just wrap them up in a new case of <code>Value</code>.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Value</span> <span class="ot">=</span> <span class="op">...</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>           <span class="op">|</span> <span class="dt">DefRec</span> <span class="dt">Name</span> <span class="dt">Expr</span> <span class="dt">Env</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a><span class="ot">elab ::</span> <span class="dt">Defn</span> <span class="ot">-&gt;</span> <span class="dt">Env</span> <span class="ot">-&gt;</span> <span class="dt">Env</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>elab (<span class="dt">Val</span> x e) env <span class="ot">=</span> define x (eval e env) env</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>elab (<span class="dt">Rec</span> x e) env <span class="ot">=</span> <span class="dt">DefRec</span> x e env</span></code></pre></div>
<p>And we're mostly done here, just a few loose strings to be wrapped up later.</p>
<h2>Church encodings (and decodings)</h2>
<p>Let's take a step back. The goal is to turn programs into lambda terms. Such a transformation is called a <a href="https://en.wikipedia.org/wiki/Church_encoding">Church encoding</a>.</p>
<p>We'll start by encoding some base values, and using those to build up to encodings for entire programs. The first thing to do is to encode the constant values and primitive functions.</p>
<p>Lets define a typeclass for things that have Church encodings.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Church</span> a <span class="kw">where</span><span class="ot"> church ::</span> a <span class="ot">-&gt;</span> <span class="dt">Term</span></span></code></pre></div>
<p>Church encodings of the boolean values <code>True = \ab.a</code> and <code>False = \ab.b</code> and the boolean operators <code>and</code>, <code>not</code>, and <code>or</code> are well known. As are encodings for the natural numbers and addition, subtraction, multiplication, comparisons, and test for zero. Division and modulo is a little more involved, but not unbearable.</p>
<p>Another standard construction is the ordered pair, with terms <code>pair = \xyz.zxy</code>, <code>fst = \p.p(\ab.a)</code> and <code>snd = \p.p(\ab.b)</code> such that <code>fst (pair x y) = x</code> and <code>snd (pair x y) =yq</code>.</p>
<p>From here we can define integers as pairs of natural numbers, where the pair <code>(n,m)</code> represents the integer <code>n-m</code>. It is not hard to extend arithmetic and comparisons from naturals to integers. The only complication is again division and modulo, in which case we have to normalize an integer (put it in the form <code>(n,0)</code> or <code>(0,n)</code>) and then extract the absolute value and sign.</p>
<p>How could we encode a list? Recall the Haskell definition of a list, <code>List a = Nil | Cons a (List a)</code>. When we write a function that takes a list as argument, we usually pattern match on the structure of the list, like so:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="fu">map</span><span class="ot"> ::</span> (a<span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">List</span> a <span class="ot">-&gt;</span> <span class="dt">List</span> b</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="fu">map</span> f l <span class="ot">=</span> <span class="kw">case</span> l <span class="kw">of</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Nil</span> <span class="ot">-&gt;</span> <span class="dt">Nil</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>  (<span class="dt">Cons</span> x xs) <span class="ot">-&gt;</span> <span class="dt">Cons</span> (f x) (<span class="fu">map</span> f xs)</span></code></pre></div>
<p>So we can think of a function on a list as consisting of two functions. The first is a constant, and it's returned in the case that list is <code>Nil</code>. The second takes two arguments (the head and tail) and is called <em>with the arguments <code>x</code> and <code>xs</code></em> if the list is <code>Cons x xs</code>.</p>
<p>Hence we may encode a list <code>l</code> as the term <code>[l]</code>, where <code>[Nil] = \ab.a</code> and <code>[Cons x y] = \ab.bxy</code>. Then a function with a list argument may be written like:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="ot">f ::</span> <span class="dt">List</span> a <span class="ot">-&gt;</span> <span class="dt">List</span> b</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>f l <span class="ot">=</span> <span class="kw">case</span> l <span class="kw">of</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Nil</span> <span class="ot">-&gt;</span> e1</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>  (<span class="dt">Cons</span> x xs) <span class="ot">-&gt;</span> e2 x xs</span></code></pre></div>
<p>and we can translate it to <code>f = \l.l(e1)(e2)</code>.</p>
<p>So we have the terms <code>cons = \xyab.bxy</code> and <code>nil = ab.a</code>. Then if we can encode values of type <code>a</code> we can also encode values of type <code>[a]</code>:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Church</span> a <span class="ot">=&gt;</span> <span class="dt">Church</span> [a] <span class="kw">where</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>  church <span class="ot">=</span> <span class="fu">foldr</span> (\a b <span class="ot">-&gt;</span> <span class="dt">App</span> (<span class="dt">App</span> cons a) b) nil <span class="op">.</span> <span class="fu">map</span> church</span></code></pre></div>
<p><a href="https://en.wikipedia.org/wiki/Mogensenâ€“Scott_encoding">In fact this generalizes to arbitrary abstract data types.</a></p>
<p>So we can encode lambda terms too.</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Church</span> <span class="dt">Term</span> <span class="kw">where</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>  church (<span class="dt">Var</span> (<span class="dt">Name</span> n)) <span class="ot">=</span> abss <span class="st">&quot;abc&quot;</span> <span class="op">$</span> <span class="dt">App</span> (v<span class="st">&quot;a&quot;</span>) (church n)</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>  church (<span class="dt">App</span> s t) <span class="ot">=</span> abss <span class="st">&quot;abc&quot;</span> <span class="op">$</span> app2 (v<span class="st">&quot;b&quot;</span>) (church s) (church t)</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>  church (<span class="dt">Abs</span> (<span class="dt">Name</span> n) s) <span class="ot">=</span> abss <span class="st">&quot;abc&quot;</span> <span class="op">$</span> app2 (v <span class="st">&quot;c&quot;</span>) (church n) (church s)</span></code></pre></div>
<p>This has the consequence that if <code>t</code> is an encoded term, we can represent a match expression:</p>
<pre><code>match t as
  (Var x) (e1)
  (App s t) (e2)
  (Abs y p) (e3)</code></pre>
<p>as the application <code>t(e1)(e2)(e3)</code>, which reduces to (e1)x if <code>t</code> encodes the term <code>Var x</code>, and so on. We have something similar for <code>if</code> expressions: if <code>c</code> is an encoded boolean then the expression <code>if c then a else b</code> can be encoded as <code>cab</code>. So we can finish our definiton of <code>eval</code>:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>act m<span class="op">@</span>(<span class="dt">Match</span> x (y,e1) (s,t,e2) (z,u,e3)) env <span class="ot">=</span> <span class="kw">case</span> act x env <span class="kw">of</span> </span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>  <span class="op">...</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>  v <span class="ot">-&gt;</span> <span class="dt">Application</span> v [<span class="dt">Closure</span> [y] e1 env, <span class="dt">Closure</span> [s,t] e2 env, <span class="dt">Closure</span> [z,u] e3 env]</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>act (<span class="dt">If</span> c e1 e2) env <span class="ot">=</span> <span class="kw">case</span> (act c env) <span class="kw">of</span></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">...</span></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>  v <span class="ot">-&gt;</span> <span class="dt">Application</span> v [act e1 env, act e2 env]</span></code></pre></div>
<p>We can encode characters directly as natural numbers, using Haskell's <code>Enum</code> typeclass. This, combined with the previous, gives us an encoding of strings.</p>
<p>We can also go back the other way, from encoded terms to Haskell values. We must be careful about alpha conversion though. In all cases we assume that the term to be decoded is in normal form.</p>
<p>A natural number looks like <code>\fx.f(f(...f(fx)...))</code>. So we can decode a term in that form by just counting how many <code>f</code>s there are. The <code>unfoldr</code> function lets us do this in a nice way.</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="ot">unApp&#39; ::</span> <span class="dt">Name</span> <span class="ot">-&gt;</span> <span class="dt">Term</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Name</span>, <span class="dt">Term</span>)</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>unApp&#39; x (<span class="dt">App</span> (<span class="dt">Var</span> y) s) <span class="ot">=</span> <span class="kw">if</span> x<span class="op">==</span>y <span class="kw">then</span> <span class="dt">Just</span> (x, s) <span class="kw">else</span> <span class="dt">Nothing</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>unApp&#39; _ _ <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a><span class="ot">unNat ::</span> <span class="dt">Term</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> </span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>unNat (<span class="dt">Abs</span> f (<span class="dt">Abs</span> x t)) <span class="ot">=</span> <span class="fu">length</span> <span class="op">.</span> unfoldr (unApp&#39; f) <span class="op">$</span> t </span></code></pre></div>
<p>And from here it is straightforward to decode every other type we have introduced.</p>
<h2>Lambda terms with holes</h2>
<p>To turn <code>Value</code>s into <code>Term</code>s, we'll find it helpful to introduce another intermediate form. It is quite common to write lambda-terms like <code>w = \x.x, W = ww</code>. Now in the definition of <code>W</code>, <code>w</code> is not a variable, but a reference to the previously defined term. We will want to do something similar, represent things with a term-like structure but possibly containing other values as well, so that the value <code>Application (VarVal "+") [VarVal "x", NumVal "3"]</code> will turn into something like <code>+x3</code>, and then we can translate the <code>+</code> and <code>3</code> into lambda-terms.</p>
<p>We can hence consider a type of "almost terms", things with a term-like structure but possibly containing other values.</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Partial</span> a <span class="ot">=</span> <span class="dt">PVar</span> <span class="dt">Name</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>               <span class="op">|</span> <span class="dt">PApp</span> (<span class="dt">Partial</span> a) (<span class="dt">Partial</span> a)</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>               <span class="op">|</span> <span class="dt">PAbs</span> <span class="dt">Name</span> (<span class="dt">Partial</span> a)</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>               <span class="op">|</span> <span class="dt">Hole</span> a</span></code></pre></div>
<p>What types of things will we want to put in? For now, the constant values and primitive functions.</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Const</span> <span class="ot">=</span> <span class="dt">CInt</span> <span class="dt">In</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>           <span class="op">|</span> <span class="dt">CBool</span> <span class="dt">Bool</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>           <span class="op">|</span> <span class="dt">CChar</span> <span class="dt">Char</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>           <span class="op">|</span> <span class="dt">CList</span> [<span class="dt">Partial</span> <span class="dt">Const</span>]</span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>           <span class="op">|</span> <span class="dt">CString</span> <span class="dt">String</span></span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>           <span class="op">|</span> <span class="dt">CPrim</span> <span class="dt">Prim</span></span></code></pre></div>
<p>It is clear how to make <code>Const</code> an instance of <code>Church</code>. And in fact, we can do something more. If we have an instance of <code>Church a</code>, then we can define an instance of <code>Church (Partial a)</code> in the obvious way!</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Church</span> a <span class="ot">=&gt;</span> <span class="dt">Church</span> (<span class="dt">Partial</span> a) <span class="kw">where</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>  church p <span class="ot">=</span> <span class="kw">case</span> p <span class="kw">of</span></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>    (<span class="dt">PVar</span> x) <span class="ot">-&gt;</span> <span class="dt">Var</span> x</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>    (<span class="dt">PApp</span> s t) <span class="ot">-&gt;</span> <span class="dt">App</span> (church s) (church t)</span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>    (<span class="dt">PAbs</span> x s) <span class="ot">-&gt;</span> <span class="dt">Abs</span> x (church s)</span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>    (<span class="dt">Hole</span> x) <span class="ot">-&gt;</span> church x </span></code></pre></div>
<p>We are very close to being done, we just need to actually turn <code>Value</code>s into <code>Partial Const</code>s. The constant values translate in the obvious way.</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="ot">partial ::</span> <span class="dt">Value</span> <span class="ot">-&gt;</span> <span class="dt">Partial</span> <span class="dt">Const</span> </span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>partial (<span class="dt">VarVal</span> x) <span class="ot">=</span> <span class="dt">PVar</span> x</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>partial (<span class="dt">NumVal</span> n) <span class="ot">=</span> <span class="dt">Hole</span> (<span class="dt">CInt</span> n)</span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>partial (<span class="dt">BoolVal</span> a) <span class="ot">=</span> <span class="dt">Hole</span> (<span class="dt">CBool</span> a)</span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>partial (<span class="dt">CharVal</span> c) <span class="ot">=</span> <span class="dt">Hole</span> (<span class="dt">CChar</span> c)</span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a>partial (<span class="dt">StringVal</span> s) <span class="ot">=</span> <span class="dt">Hole</span> (<span class="dt">CString</span> s)</span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a>partial (<span class="dt">ListVal</span> xs) <span class="ot">=</span> <span class="dt">Hole</span> (<span class="dt">CList</span> (<span class="fu">map</span> partial xs))</span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a>partial (<span class="dt">Primitive</span> p) <span class="ot">=</span> <span class="dt">Hole</span> (<span class="dt">CPrim</span> p)</span></code></pre></div>
<p>Applications are straightforward too. For the closure <code>Closure [x1...xn] e env</code>, which we recall represents a function taking the arguments <code>x1, ... xn</code> to the value of <code>e</code> in the environment <code>env</code>, we partial-ize the body and bind the arguments.</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>partial (<span class="dt">Application</span> f es) <span class="ot">=</span> <span class="fu">foldl</span> (<span class="dt">PApp</span>) (partial f) <span class="op">.</span> <span class="fu">map</span> partial <span class="op">$</span> ex </span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>partial (<span class="dt">Closure</span> xs e env) <span class="ot">=</span>  <span class="fu">foldr</span> (<span class="dt">PAbs</span>) (partial <span class="op">$</span> eval e env) xs </span></code></pre></div>
<p>We can think of a recursive definition <code>rec x = e</code> as wanting <code>x</code> to satisfy the equation <code>x = e</code>, where <code>x</code> may be a free variable in <code>e</code>. The standard trick here is to take x as the term <code>Y (\x.e)</code>, where Y is Church's fixed point combinator. So we define such a term <code>y</code> and add <code>Y</code> as a <code>Const</code>.</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Const</span> <span class="ot">=</span> <span class="op">...</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>           <span class="op">|</span> <span class="dt">Y</span></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>partial (<span class="dt">DefRec</span> x e env) <span class="ot">=</span> <span class="dt">PApp</span> (<span class="dt">Hole</span> <span class="dt">Y</span>) (partial <span class="op">$</span> <span class="dt">Closure</span> [x] e env)</span></code></pre></div>
<p>So now we have a full chain, <code>parse :: String -&gt; Expr</code>, <code>eval :: Expr -&gt; Env -&gt; Value</code>, <code>partial :: Value -&gt; Partial Const</code>, and <code>church :: Partial Const -&gt; Term</code>!</p>
<p>A simple compiler could be defined as:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>  [source] <span class="ot">&lt;-</span> getArgs</span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> <span class="op">.</span> church <span class="op">.</span> partial <span class="op">$</span> eval (parse source) prims</span></code></pre></div>
<p>It is not too hard to add some optional flags for allowing reading from input files, writing to output files, etc. But how might we write a REPL?</p>
<h2>Reduction</h2>
<p>Before we do that however, let's take a small diversion. The compiler above will, given the input ~~~ let rec f = func (x) (x) in f true ~~~ produce the term ~~~ ((\f.((\x.(f (x x))) (\x.(f (x x))))) (\f x.x)) \a b.a ~~~</p>
<p>This is correct, but we'd like it to produce the fully reduced version instead, simply <code>'a b.a</code>. We have [already seen]({{&lt;relref "bnfterm.markdown"&gt;}}) how to find beta-normal forms of terms.</p>
<p>Let's try to implement head reduction. We can head-reduce a term by stripping off the abstractions, and then unpeeling the applications until we get to the head. If it's an abstraction then we can beta-reduce, otherwise we can't do anything.</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="ot">unabs ::</span> <span class="dt">Term</span> <span class="ot">-&gt;</span> [<span class="dt">Name</span>] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Term</span>, [<span class="dt">Name</span>])</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>unabs t<span class="op">@</span>(<span class="dt">App</span> p q) ns <span class="ot">=</span> <span class="dt">Just</span> (t, ns)</span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>unabs (<span class="dt">Abs</span> n s) ns <span class="ot">=</span>  unabs s (n<span class="op">:</span>ns) </span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>unabs _ ns <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a><span class="ot">unapp ::</span> <span class="dt">Term</span> <span class="ot">-&gt;</span> [<span class="dt">Term</span>] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Name</span>, <span class="dt">Term</span>, <span class="dt">Term</span>, [<span class="dt">Term</span>])</span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a>unapp (<span class="dt">App</span> (<span class="dt">Abs</span> x t) u) ts <span class="ot">=</span> <span class="dt">Just</span> (x, t, u, ts) </span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true" tabindex="-1"></a>unapp (<span class="dt">App</span> p q) ts <span class="ot">=</span> unapp p (q<span class="op">:</span>ts) </span>
<span id="cb34-9"><a href="#cb34-9" aria-hidden="true" tabindex="-1"></a>unapp _ ts <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb34-10"><a href="#cb34-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-11"><a href="#cb34-11" aria-hidden="true" tabindex="-1"></a><span class="ot">hred ::</span> <span class="dt">Term</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Term</span></span>
<span id="cb34-12"><a href="#cb34-12" aria-hidden="true" tabindex="-1"></a>hred p <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb34-13"><a href="#cb34-13" aria-hidden="true" tabindex="-1"></a>  (app, is) <span class="ot">&lt;-</span> unabs p []</span>
<span id="cb34-14"><a href="#cb34-14" aria-hidden="true" tabindex="-1"></a>  (x,t,u,ts) <span class="ot">&lt;-</span> unapp app []</span>
<span id="cb34-15"><a href="#cb34-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> h <span class="ot">=</span> sub t u x</span>
<span id="cb34-16"><a href="#cb34-16" aria-hidden="true" tabindex="-1"></a>      h&#39; <span class="ot">=</span> <span class="fu">foldl</span> <span class="dt">App</span> h ts</span>
<span id="cb34-17"><a href="#cb34-17" aria-hidden="true" tabindex="-1"></a>      h&#39;&#39; <span class="ot">=</span> <span class="fu">foldr</span> <span class="dt">Abs</span> h&#39; is</span>
<span id="cb34-18"><a href="#cb34-18" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> h&#39;&#39;</span>
<span id="cb34-19"><a href="#cb34-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-20"><a href="#cb34-20" aria-hidden="true" tabindex="-1"></a><span class="ot">hnf ::</span> <span class="dt">Term</span> <span class="ot">-&gt;</span> <span class="dt">Term</span></span>
<span id="cb34-21"><a href="#cb34-21" aria-hidden="true" tabindex="-1"></a>hnf t <span class="ot">=</span> <span class="kw">case</span> hred t <span class="kw">of</span></span>
<span id="cb34-22"><a href="#cb34-22" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Just</span> t&#39; <span class="ot">-&gt;</span> hnf t&#39;</span>
<span id="cb34-23"><a href="#cb34-23" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Nothing</span> <span class="ot">-&gt;</span> t </span></code></pre></div>
<h2>Monad of environments</h2>
<p>Consider a simple GHCi-like REPL. There is a persistent environment that can be modified by entering definitions. Entering an expression will evaluate it in the current environment. You can load definitions from files, and refresh them.</p>
<p>We can model this behaviour by defining a monad of environments. Or rather, a monad transformer.</p>
<p>First though, we should refine our definition of environments. We will want to seperate the environment into several base environments that have been loaded from files, and the current user environment. A reload command should wipe the user-added definitions, and reload the files.</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Module</span> a <span class="ot">=</span> <span class="dt">Module</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> module_name ::</span> <span class="dt">String</span></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> module_env ::</span> <span class="dt">Environment</span> a</span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> module_reload ::</span> <span class="dt">IO</span> (<span class="dt">Maybe</span> (<span class="dt">Environment</span> a))</span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Environments</span> a <span class="ot">=</span> <span class="dt">Environments</span> </span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> current_env ::</span> <span class="dt">Environment</span> a</span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> loaded_modules ::</span>  <span class="dt">Map.Map</span> <span class="dt">String</span> (<span class="dt">Module</span> a)</span>
<span id="cb35-9"><a href="#cb35-9" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb35-10"><a href="#cb35-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> <span class="dt">Eq</span></span></code></pre></div>
<p>A module will have a name, a bunch of definitions that get turned into an environment, and a way of reloading itself. An <code>Environments</code> object will contain a bunch of modules and a current environment.</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">EnvT</span> v m a <span class="ot">=</span> <span class="dt">EnvT</span> {<span class="ot">runEnvT ::</span> <span class="dt">Environments</span> v <span class="ot">-&gt;</span> m (a, <span class="dt">Environments</span> v) }</span></code></pre></div>
<p>If <code>m</code> is a monad then <code>EnvT v m</code> wraps <code>m</code> in an environment with values of type <code>v</code>. This is a specialized version of the <code>StateT</code> transformer. We now add some instances.</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> m <span class="ot">=&gt;</span> <span class="dt">Functor</span> (<span class="dt">EnvT</span> v  m) <span class="kw">where</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">fmap</span> f xm <span class="ot">=</span> <span class="dt">EnvT</span> ( \e <span class="ot">-&gt;</span> <span class="fu">fmap</span> (\(a,e) <span class="ot">-&gt;</span> (f a, e)) <span class="op">$</span> runEnvT xm e )</span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Applicative</span> (<span class="dt">EnvT</span> v m) <span class="kw">where</span></span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pure</span> <span class="ot">=</span> <span class="fu">return</span></span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a>  (<span class="op">&lt;*&gt;</span>) <span class="ot">=</span> ap</span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Monad</span> (<span class="dt">EnvT</span> v m) <span class="kw">where</span></span>
<span id="cb37-9"><a href="#cb37-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> x <span class="ot">=</span> <span class="dt">EnvT</span> (\e <span class="ot">-&gt;</span> <span class="fu">return</span> (x,e))</span>
<span id="cb37-10"><a href="#cb37-10" aria-hidden="true" tabindex="-1"></a>  xm <span class="op">&gt;&gt;=</span> f <span class="ot">=</span> <span class="dt">EnvT</span> (\e <span class="ot">-&gt;</span>  runEnvT xm e <span class="op">&gt;&gt;=</span> (\(a,e&#39;) <span class="ot">-&gt;</span> runEnvT (f a) e&#39; )  )  </span>
<span id="cb37-11"><a href="#cb37-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-12"><a href="#cb37-12" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">MonadTrans</span> (<span class="dt">EnvT</span> v) <span class="kw">where</span></span>
<span id="cb37-13"><a href="#cb37-13" aria-hidden="true" tabindex="-1"></a>  lift xm <span class="ot">=</span> <span class="dt">EnvT</span> (\e <span class="ot">-&gt;</span> xm <span class="op">&gt;&gt;=</span> (\a <span class="ot">-&gt;</span> <span class="fu">return</span> (a,e)))</span>
<span id="cb37-14"><a href="#cb37-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-15"><a href="#cb37-15" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">MonadIO</span> m <span class="ot">=&gt;</span> <span class="dt">MonadIO</span> (<span class="dt">EnvT</span> v m) <span class="kw">where</span></span>
<span id="cb37-16"><a href="#cb37-16" aria-hidden="true" tabindex="-1"></a>  liftIO <span class="ot">=</span> lift <span class="op">.</span> liftIO</span></code></pre></div>
<p>Now we define some helper functions. Some things we'll want to with an <code>Environments a</code> are: * Define a default one * Add a new module * Reload all modules * Lookup a name * Add a definition to the current env * Return a list of module names * Replace the current env with a different one So let's get to it!</p>
<p>The default will be empty.</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="ot">new_env_ ::</span> <span class="dt">Environment</span> a</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>new_env_ <span class="ot">=</span> []</span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a><span class="ot">new_env ::</span> <span class="dt">Environments</span> a</span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a>new_env <span class="ot">=</span> <span class="dt">Environments</span></span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a>  { current_env <span class="ot">=</span> new_env_</span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true" tabindex="-1"></a>  , loaded_modules <span class="ot">=</span> Map.empty</span>
<span id="cb38-8"><a href="#cb38-8" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<p>Adding a new module is not hard.</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="ot">addEnv ::</span> <span class="dt">Environments</span> a <span class="ot">-&gt;</span> <span class="dt">Module</span> a <span class="ot">-&gt;</span> <span class="dt">Environments</span> a</span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>addEnv envs m<span class="ot">=</span> envs{loaded_modules <span class="ot">=</span> Map.insert (module_name m) m (loaded_modules envs)}</span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a><span class="ot">addM ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Module</span> a <span class="ot">-&gt;</span> <span class="dt">EnvT</span> a m ()</span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a>addM m <span class="ot">=</span> <span class="dt">EnvT</span> (\e <span class="ot">-&gt;</span> <span class="fu">return</span> ((), addEnv e m))</span></code></pre></div>
<p>To reload the loaded modules we try to call each of their reload methods.</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="ot">reload ::</span> <span class="dt">Module</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Maybe</span> (<span class="dt">Module</span> a))</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>reload m <span class="ot">=</span> module_reload m <span class="op">&gt;&gt;=</span> \<span class="kw">case</span> </span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Just</span> env <span class="ot">-&gt;</span> <span class="fu">return</span> <span class="op">.</span> <span class="dt">Just</span> <span class="op">$</span> m{module_env<span class="ot">=</span>env}</span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="fu">return</span> <span class="dt">Nothing</span></span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a><span class="ot">reloadM ::</span> <span class="dt">MonadIO</span> m <span class="ot">=&gt;</span> <span class="dt">Environments</span> a <span class="ot">-&gt;</span> m (<span class="dt">Environments</span> a)</span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a>reloadM envs <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true" tabindex="-1"></a>  ms <span class="ot">&lt;-</span> liftIO <span class="op">.</span> <span class="fu">sequence</span> <span class="op">$</span> Map.map reload (loaded_modules envs) </span>
<span id="cb40-8"><a href="#cb40-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> <span class="op">$</span> new_env {loaded_modules <span class="ot">=</span> Map.foldr f (Map.empty) ms, current_env <span class="ot">=</span> new_env_} </span>
<span id="cb40-9"><a href="#cb40-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb40-10"><a href="#cb40-10" aria-hidden="true" tabindex="-1"></a>  f x ys <span class="ot">=</span> <span class="kw">case</span> x <span class="kw">of</span></span>
<span id="cb40-11"><a href="#cb40-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Nothing</span> <span class="ot">-&gt;</span> ys</span>
<span id="cb40-12"><a href="#cb40-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Just</span> y <span class="ot">-&gt;</span> Map.insert (module_name y) y ys</span></code></pre></div>
<p>For simplicity, we do not enforce unique definitions. So to look up a name we just iterate through the loaded modules in order.</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="ot">find1 ::</span> <span class="dt">Environment</span> a <span class="ot">-&gt;</span> <span class="dt">Name</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>find1 env x <span class="ot">=</span> <span class="kw">case</span> (<span class="fu">filter</span> (\(a,b) <span class="ot">-&gt;</span> a<span class="op">==</span>x) env) <span class="kw">of</span></span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a>  [] <span class="ot">-&gt;</span> <span class="dt">Nothing</span></span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a>  ((a,b)<span class="op">:</span>xs) <span class="ot">-&gt;</span> <span class="dt">Just</span> b </span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a><span class="ot">find ::</span> <span class="dt">Environments</span> a <span class="ot">-&gt;</span> <span class="dt">Name</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a>find envs x <span class="ot">=</span> <span class="kw">let</span> </span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true" tabindex="-1"></a>  y <span class="ot">=</span> find1 (current_env envs) x </span>
<span id="cb41-8"><a href="#cb41-8" aria-hidden="true" tabindex="-1"></a>  ys <span class="ot">=</span> <span class="fu">map</span> (\m <span class="ot">-&gt;</span> find1 (module_env m) x) <span class="op">.</span> Map.elems <span class="op">.</span> loaded_modules <span class="op">$</span> envs <span class="kw">in</span></span>
<span id="cb41-9"><a href="#cb41-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">foldr</span> (<span class="op">&lt;|&gt;</span>) (<span class="dt">Nothing</span>) (y<span class="op">:</span>ys)</span>
<span id="cb41-10"><a href="#cb41-10" aria-hidden="true" tabindex="-1"></a><span class="ot">findM ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Name</span> <span class="ot">-&gt;</span> <span class="dt">EnvT</span> v m (<span class="dt">Maybe</span> v)</span>
<span id="cb41-11"><a href="#cb41-11" aria-hidden="true" tabindex="-1"></a>findM n <span class="ot">=</span> <span class="dt">EnvT</span> (\e <span class="ot">-&gt;</span> <span class="fu">return</span> (find e n, e))</span></code></pre></div>
<div class="sourceCode" id="cb42"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="ot">define1 ::</span> <span class="dt">Environment</span> a <span class="ot">-&gt;</span> <span class="dt">Name</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Environment</span> a</span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a>define1 env x v <span class="ot">=</span> (x,v)<span class="op">:</span>env</span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a><span class="ot">define ::</span> <span class="dt">Environments</span> a <span class="ot">-&gt;</span> <span class="dt">Name</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Environments</span> a</span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a>define envs x v <span class="ot">=</span> envs{current_env <span class="ot">=</span> define1 (current_env envs) x v}</span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a><span class="ot">defineM ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Name</span> <span class="ot">-&gt;</span> v <span class="ot">-&gt;</span> <span class="dt">EnvT</span> v m ()</span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a>defineM x v <span class="ot">=</span> <span class="dt">EnvT</span> (\e <span class="ot">-&gt;</span> <span class="fu">return</span>((), define e x v ))</span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-8"><a href="#cb42-8" aria-hidden="true" tabindex="-1"></a><span class="ot">defs1 ::</span> <span class="dt">Environment</span> a <span class="ot">-&gt;</span> [(<span class="dt">Name</span>, a)] <span class="ot">-&gt;</span> <span class="dt">Environment</span> a</span>
<span id="cb42-9"><a href="#cb42-9" aria-hidden="true" tabindex="-1"></a>defs1 <span class="ot">=</span> <span class="fu">flip</span> (<span class="op">++</span>) </span>
<span id="cb42-10"><a href="#cb42-10" aria-hidden="true" tabindex="-1"></a><span class="ot">defs ::</span> <span class="dt">Environments</span> a <span class="ot">-&gt;</span> [(<span class="dt">Name</span>, a)] <span class="ot">-&gt;</span> <span class="dt">Environments</span> a</span>
<span id="cb42-11"><a href="#cb42-11" aria-hidden="true" tabindex="-1"></a>defs envs ds <span class="ot">=</span> envs{current_env <span class="ot">=</span> defs1 (current_env envs) ds}</span>
<span id="cb42-12"><a href="#cb42-12" aria-hidden="true" tabindex="-1"></a><span class="ot">defsM ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> [(<span class="dt">Name</span>, v)] <span class="ot">-&gt;</span> <span class="dt">EnvT</span> v m ()</span>
<span id="cb42-13"><a href="#cb42-13" aria-hidden="true" tabindex="-1"></a>defsM xs <span class="ot">=</span> <span class="dt">EnvT</span> (\e <span class="ot">-&gt;</span> <span class="fu">return</span> ((), defs e xs))</span></code></pre></div>
<p>We have to unwrap a few layers to add definitions to the current environment, but it's all rather standard.</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="ot">listM ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">EnvT</span> v m [<span class="dt">String</span>]</span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a>listM <span class="ot">=</span> <span class="dt">EnvT</span> (\e <span class="ot">-&gt;</span><span class="fu">return</span> (Map.keys <span class="op">.</span> loaded_modules <span class="op">$</span> e  ,e) )</span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a><span class="ot">inM ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Environments</span> v <span class="ot">-&gt;</span> <span class="dt">EnvT</span> v m ()</span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true" tabindex="-1"></a>inM env <span class="ot">=</span> <span class="dt">EnvT</span> (\e <span class="ot">-&gt;</span> <span class="fu">return</span> ((), env))</span></code></pre></div>
<p>Finally we have these two functions that return a list of the loaded modules, and replace the current environment with a provided one.</p>
<p>We will also redefine the type synonym <code>Env</code> to:</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Env</span> <span class="ot">=</span> <span class="dt">Environments</span> <span class="dt">Value</span></span></code></pre></div>
<p>So that our functions <code>eval</code> and <code>elab</code> remain monad-free, with the same type signatures.</p>
<h2>Wrapping up</h2>
<p>Now let's put this all together into a simple REPL. The structure is to: * Read instructions from the console * Parse them into commands * Execute them * Repeat</p>
<p>Suppose we had a function <code>rep :: EnvT Action IO ()</code> that, in an environment, does the first three steps above. We could turn this into a straight <code>IO ()</code> by calling <code>runEnvT rep prim</code>. But we want to keep looping, and importantly, <em>keep passing the environment around</em>. So we'll have to make the loop inside the <code>EnvT</code>, like so:</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> runEnvT (forever rep) prim</span></code></pre></div>
<p>Now we'll try to define <code>rep</code> appropriately.</p>
<p>We'll start by thinking about what kind of commands we should accept. We'll want to be able to add definitions to the environment, evaluate expresions and optionally reduce/decode them, load and reload modules, and quit. So we can define a type for commands as:</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Process</span> <span class="ot">=</span> <span class="dt">Bnf</span> <span class="op">|</span> <span class="dt">Hnf</span> <span class="op">|</span> <span class="dt">ToInt</span> <span class="op">|</span> <span class="dt">ToBool</span> <span class="op">|</span> <span class="dt">ToChar</span> <span class="op">|</span> <span class="dt">ToString</span> <span class="op">|</span> <span class="dt">None</span> </span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Command</span> <span class="ot">=</span> <span class="dt">Define</span> <span class="dt">Defn</span> </span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a>             <span class="op">|</span> <span class="dt">Evaluate</span> <span class="dt">Expr</span> <span class="dt">Process</span> </span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a>             <span class="op">|</span> <span class="dt">Reload</span> </span>
<span id="cb46-5"><a href="#cb46-5" aria-hidden="true" tabindex="-1"></a>             <span class="op">|</span> <span class="dt">Load</span> <span class="dt">String</span></span>
<span id="cb46-6"><a href="#cb46-6" aria-hidden="true" tabindex="-1"></a>             <span class="op">|</span> <span class="dt">Quit</span></span></code></pre></div>
<p>It is not hard to define a parser for these, so let's define a function <code>parseCommand :: String -&gt; Command</code> to parse them.</p>
<p>How do we execute a command?</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="ot">execute ::</span> <span class="dt">Command</span> <span class="ot">-&gt;</span> <span class="dt">EnvT</span> <span class="dt">Action</span> <span class="dt">IO</span> ()</span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>execute <span class="ot">=</span> \<span class="kw">case</span> </span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Define</span> d <span class="ot">-&gt;</span> elabM d</span></code></pre></div>
<p>Adding a definition to the environment is pretty simple now. To evaluate an expression, and then process it afterwards is straightforward too:</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="ot">process ::</span> <span class="dt">Process</span> <span class="ot">-&gt;</span> <span class="dt">Term</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a>process <span class="ot">=</span> \<span class="kw">case</span></span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Bnf</span> <span class="ot">-&gt;</span> <span class="fu">show</span> <span class="op">.</span> bnf</span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Hnf</span> <span class="ot">-&gt;</span> <span class="fu">show</span> <span class="op">.</span> hnf</span>
<span id="cb48-5"><a href="#cb48-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">ToInt</span> <span class="ot">-&gt;</span> <span class="fu">show</span> <span class="op">.</span> (<span class="ot">unchurch ::</span> <span class="dt">Term</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>)</span>
<span id="cb48-6"><a href="#cb48-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">ToBool</span> <span class="ot">-&gt;</span> <span class="fu">show</span> <span class="op">.</span> (<span class="ot">unchurch ::</span> <span class="dt">Term</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>)</span>
<span id="cb48-7"><a href="#cb48-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">ToChar</span> <span class="ot">-&gt;</span> <span class="fu">show</span> <span class="op">.</span> (<span class="ot">unchurch ::</span> <span class="dt">Term</span> <span class="ot">-&gt;</span> <span class="dt">Char</span>)</span>
<span id="cb48-8"><a href="#cb48-8" aria-hidden="true" tabindex="-1"></a>  <span class="dt">ToString</span> <span class="ot">-&gt;</span> <span class="fu">show</span> <span class="op">.</span> (<span class="ot">unchurch ::</span> <span class="dt">Term</span> <span class="ot">-&gt;</span> <span class="dt">String</span>)</span>
<span id="cb48-9"><a href="#cb48-9" aria-hidden="true" tabindex="-1"></a>  <span class="dt">None</span> <span class="ot">-&gt;</span> <span class="fu">show</span></span>
<span id="cb48-10"><a href="#cb48-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-11"><a href="#cb48-11" aria-hidden="true" tabindex="-1"></a><span class="ot">execute ::</span> <span class="dt">Command</span> <span class="ot">-&gt;</span> <span class="dt">EnvT</span> <span class="dt">Action</span> <span class="dt">IO</span> ()</span>
<span id="cb48-12"><a href="#cb48-12" aria-hidden="true" tabindex="-1"></a>execute <span class="ot">=</span> \<span class="kw">case</span> </span>
<span id="cb48-13"><a href="#cb48-13" aria-hidden="true" tabindex="-1"></a>  <span class="op">...</span></span>
<span id="cb48-14"><a href="#cb48-14" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Evaluate</span> e p <span class="ot">-&gt;</span> eval e <span class="op">&gt;&gt;=</span> (lift <span class="op">.</span> <span class="fu">putStrLn</span> <span class="op">.</span> (process p) church <span class="op">.</span> partial)</span></code></pre></div>
<p>Quitting and reloading are simple as well.</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="ot">execute ::</span> <span class="dt">Command</span> <span class="ot">-&gt;</span> <span class="dt">EnvT</span> <span class="dt">Action</span> <span class="dt">IO</span> ()</span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a>execute <span class="ot">=</span> \<span class="kw">case</span> </span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">...</span></span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Quit</span> <span class="ot">-&gt;</span> lift <span class="op">$</span> <span class="fu">putStrLn</span> <span class="st">&quot;Quiting LamER&quot;</span> <span class="op">&gt;&gt;</span> exitSuccess</span>
<span id="cb49-5"><a href="#cb49-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Reload</span> <span class="ot">-&gt;</span> envM <span class="op">&gt;&gt;=</span> lift <span class="op">.</span> reloadM <span class="op">&gt;&gt;=</span> inM</span></code></pre></div>
<p>To load a module from a file path we will find it helpful to define a function <code>loadFile :: MonadIO , =&gt; String -&gt; EnvT Action m ()</code>, that, in an environment, adds a new module from the given file path. From there it is straightforward to define the appropriate command:</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="ot">execute ::</span> <span class="dt">Command</span> <span class="ot">-&gt;</span> <span class="dt">EnvT</span> <span class="dt">Action</span> <span class="dt">IO</span> ()</span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a>execute <span class="ot">=</span> \<span class="kw">case</span> </span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">...</span></span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Load</span> path <span class="ot">-&gt;</span> loadFile path</span></code></pre></div>
<p>Now we'd like to display a prompt on each line. We have to make sure to flush the buffer so that the prompt actually appears first, but it's not too difficult.</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="ot">prompt&#39; ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">String</span></span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a>prompt&#39; text <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">putStr</span> text</span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a>    hFlush stdout</span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true" tabindex="-1"></a>    <span class="fu">getLine</span> </span></code></pre></div>
<p>Remember how we defined a function <code>listM :: Monad m =&gt; Envt a m [String]</code> that returned a list of module names from the current environment? We can now use that to define a GHCi-like prompt, that prints the names of the currently loaded modules.</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="ot">prompt ::</span>  <span class="dt">EnvT</span> <span class="dt">Action</span> <span class="dt">IO</span> <span class="dt">String</span> </span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a>prompt <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a>  ms <span class="ot">&lt;-</span> listM </span>
<span id="cb52-4"><a href="#cb52-4" aria-hidden="true" tabindex="-1"></a>  lift <span class="op">$</span> prompt&#39; (intercalate <span class="st">&quot; &quot;</span> ms <span class="op">++</span> <span class="st">&quot;&gt; &quot;</span>)</span></code></pre></div>
<p>Now we can simply define <code>rep</code> as:</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a><span class="ot">rep ::</span> <span class="dt">EnvT</span> <span class="dt">Action</span> <span class="dt">IO</span> ()</span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a>rep <span class="ot">=</span> prompt <span class="op">&gt;&gt;=</span> execute <span class="op">.</span> parseCommand</span></code></pre></div>
<p>And we are done!</p>
<h2>References</h2>
<p>The interpreter was inspired by Mike Spivey's Principles of Programming Languages lecture notes.</p>
<p>Here are some resources I found useful:</p>
<ul>
<li>http://matt.might.net/articles/compiling-up-to-lambda-calculus/</li>
<li>http://okmij.org/ftp/Computation/lambda-calc.html#neg</li>
<li>http://jwodder.freeshell.org/lambda.html</li>
<li>https://blog.jez.io/variables-and-binding/</li>
<li>https://en.wikibooks.org/wiki/Write<em>Yourself</em>a<em>Scheme</em>in<em>48</em>Hours</li>
</ul><div class="footer"><a href="http://danielmroz.co.uk">Click here to go back.</a></div></div></div><div class="footer"><p>Copyright &copy; 2022 Daniel Mroz</p></div></div></div></div></body></html>